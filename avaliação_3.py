# -*- coding: utf-8 -*-
"""Avaliação 3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mk9RpsQzFZazmJecnRmm8QsaXT-ZLkhK

Obs: Como no artigo é dito que o cromossomo pode ser do tamanho $1 \le N \le 93$, neste código optei por trabalhar com apenas 5 genes, isto é, 5 aulas por causa do tempo de processamento que o Colab permite.

O objetivo é minimizar a seguinte função fitness:

$ f = T * \sum_{i}^{n} pi  - \sum_{i}^{n} ci * pi $

onde T é o número total de aulas/palestras, ci e pi representam a violação total da i-ésima restrição e sua penalidade respectivamente.

Ou seja, buscamos aquele cromossomo que minimiza essa função.
"""

import random
import matplotlib.pyplot as plt
import math

def inicia_populacao (tamanho):
  """Inicia a populacao aleatoria"""
  return [[round(random.random(), 0) for x in range(93)] for x in range(tamanho)]

def fitness_function(individuo):
  """Retorna fitness da função"""

  PENALIDADE = [100, 100, 100, 100, 100, 10, 10, 10, 20,
               20, 20, 20, 30, 30, 30, 30]
  QUANTIDADE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  
  T = len(individuo)
  SOMA1 = 0
  SOMA2 = 0
  
  for i in individuo:

    if i == 1:
      p = random.randint(0,15)  # escolhe uma penalidade aleatória para essa aula 
      SOMA1 += PENALIDADE[p]

      QUANTIDADE[p] += 1 #Soma a quantidade de cada ocorrência de uma penalidade
      SOMA2 += (QUANTIDADE[p] * PENALIDADE[p])
  return T * SOMA1 - SOMA2

  
def recombinacao(individuo1, individuo2):
  """Recombina os individuos em 10 genes"""
  
  TAM = len(individuo1)
  for i in range(50):
    
    k = random.randint(0, TAM-1)
    j = random.randint(0, TAM-1)
    
    if j == k:
      j = random.randint(0, TAM-1)
    individuo1[k] = individuo2[j]

  
  return individuo1

def avalia_populacao(populacao):
	"""Função que avalia a população"""
	return [fitness_function(i) for i in populacao]

def nova_geracao(populacao, novos_individuos):
  """Cria uma nova geração com uma populacao
   a partir dos 100 melhores"""

  pf = populacao + novos_individuos
  fits = sorted(list(zip(avalia_populacao(pf), pf)), reverse = False)
  return [fits[i][1] for i in range(100)]



def mutacao(novo_individuo, taxa_mutacao):
  if random.uniform(0,1) < taxa_mutacao:
    a = len(novo_individuo)
    i = random.randint(0,a-1)
    novo_individuo[i] = random.randint(0, 1)
  return novo_individuo

# Algoritmo genético sem MUTAÇÃO, mas com recombinação

tam_da_populacao = 10000
num_de_geracoes = 50
num_de_recombinacao = 50
best_fits = []

populacao = inicia_populacao(tam_da_populacao)

for i in range(num_de_geracoes):
  novos_individuos = []
  for j in range(num_de_recombinacao):
    random.shuffle(populacao)
    TAM = len(populacao) 
    k = random.randint(0, TAM-1)
    y = random.randint(0, TAM-1)
    a = recombinacao(populacao[k], populacao[y])
    novos_individuos.append(a)
  populacao_e_filhos = populacao + novos_individuos
  fits = avalia_populacao(populacao_e_filhos)
  best_fits.append(min(fits))
  populacao = nova_geracao(populacao, novos_individuos)

best_fits

plt.plot(best_fits)

# Algoritmo genético com MUTAÇÃO e com recombinação

tam_da_populacao = 1000
num_de_geracoes = 80
num_de_recombinacao = 65
best_fits = []
taxa_de_mutacao = 0.25

populacao = inicia_populacao(tam_da_populacao)

for i in range(num_de_geracoes):
  novos_individuos = []
  
  for j in range(num_de_recombinacao):
    random.shuffle(populacao)
    TAM = len(populacao) 
    k = random.randint(0, TAM-1)
    y = random.randint(0, TAM-1)
    novo_individuo = recombinacao(populacao[k], populacao[y])
    novos_individuos.append(mutacao(novo_individuo, taxa_de_mutacao))

  populacao_e_filhos = populacao + novos_individuos
  fits = avalia_populacao(populacao_e_filhos)
  best_fits.append(min(fits))
  populacao = nova_geracao(populacao, novos_individuos)

best_fits

plt.plot(best_fits)